/*
 * @lc app=leetcode.cn id=924 lang=javascript
 * @lcpr version=30300
 *
 * [924] 尽量减少恶意软件的传播
 */

import { ListNode } from "../common/listNode.js";
import { TreeNode } from "../common/treeNode.js";

// @lc code=start
/**
 * v1 BFS
 * 题目让我们删除一个初始感染节点，使得最终感染的节点数最小，
 * 其实就是让我们找一个只有一个节点被感染的连通分量，且这个连通分量中的节点数最多。
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
const minMalwareSpread = function (graph, initial) {
  const n = graph.length;
  const initialSet = new Set(initial);
  const visited = new Array(n).fill(false);
  initial.sort((a, b) => a - b); // 升序排序

  let targetNode = initial[0];
  let reduceCount = 0;
  for (const badNode of initial) {
    if (visited[badNode]) continue;
    // 返回当前感染节点所在连通分量的大小和该连通风量中初始感染节点的个数
    const count = bfs(graph, badNode, initialSet, visited);
    // 只有一个初始感染节点
    if (count[1] === 1) {
      if (count[0] > reduceCount) {
        targetNode = badNode;
        reduceCount = count[0];
      }
    }
  }

  return targetNode;
};

const bfs = (graph, badNode, initialSet, visited) => {
  let nodeCount = 0;
  let badCount = 0;
  const q = [badNode];
  visited[badNode] = true;

  while (q.length > 0) {
    const node = q.shift();
    nodeCount++;
    if (initialSet.has(node)) badCount++;

    for (let i = 0; i < graph[node].length; i++) {
      if (graph[node][i] === 1 && !visited[i]) {
        visited[i] = true;
        q.push(i);
      }
    }
  }

  return [nodeCount, badCount];
};
// @lc code=end

// your test code here
minMalwareSpread(
  [
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, 1],
    [0, 0, 1, 1],
  ],
  [3, 1]
);
/*
// @lcpr case=start
// [[1,1,0],[1,1,0],[0,0,1]]\n[0,1]\n
// @lcpr case=end

// @lcpr case=start
// [[1,0,0],[0,1,0],[0,0,1]]\n[0,2]\n
// @lcpr case=end

// @lcpr case=start
// [[1,1,1],[1,1,1],[1,1,1]]\n[1,2]\n
// @lcpr case=end

 */
